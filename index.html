<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Jeu Labyrinthe 3D Extrême</title>
  <style>
    /* Basic resets and layout */
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #111;
      color: #fff;
      font-family: Arial, sans-serif;
    }
    /* Overlay used before pointer lock is engaged */
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1;
      text-align: center;
    }
    #overlay img {
      max-width: 80%;
      height: auto;
      margin-bottom: 1rem;
      border-radius: 8px;
    }
    #overlay button {
      padding: 0.5rem 1.5rem;
      font-size: 1.25rem;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      background: #5a9e30;
      color: white;
    }
    #overlay button:hover {
      background: #4a8b29;
    }
    /* Status message in the top left corner */
    #status {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.5);
      padding: 0.5rem 1rem;
      border-radius: 4px;
      font-size: 1rem;
      z-index: 2;
    }
  </style>
</head>
<body>
  <!-- Overlay with title, image and start button -->
  <div id="overlay">
    <h1>Bienvenue dans le labyrinthe 3D !</h1>
    <p>Utilisez les touches WASD ou les flèches pour vous déplacer.<br />Cliquez sur le bouton pour commencer.</p>
    <button id="startButton">Commencer</button>
  </div>
  <!-- Status display (e.g. victory message) -->
  <div id="status"></div>
  <!-- Main script: generates the maze and handles the 3D scene -->
  <script type="module">
    // Import Three.js core and PointerLockControls from CDN.  Module import is used so that
    // we can leverage ES module syntax in the browser without bundling.
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js';
    import { PointerLockControls } from 'https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/controls/PointerLockControls.js';

    /*
     * Maze generation using a randomized depth‑first search.  The maze is represented as a
     * two‑dimensional array where 0 indicates a passage and 1 indicates a wall.  To
     * construct passages, we carve through walls in steps of two cells, knocking down
     * intermediate walls to create a single cell wide corridor.  The boundaries remain
     * intact to avoid the player walking off the map.  Start and end points are
     * explicitly cleared.
     */
    function generateMaze(width, height) {
      const maze = Array.from({ length: height }, () => Array(width).fill(1));
      const stack = [];
      // relative moves of two cells in each cardinal direction
      const directions = [ [0, -2], [2, 0], [0, 2], [-2, 0] ];
      // start at (1,1) to avoid carving on the outer border
      let cx = 1;
      let cy = 1;
      maze[cy][cx] = 0;
      stack.push([cx, cy]);
      while (stack.length) {
        const [x, y] = stack[stack.length - 1];
        const neighbors = [];
        for (const [dx, dy] of directions) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx > 0 && ny > 0 && nx < width - 1 && ny < height - 1 && maze[ny][nx] === 1) {
            neighbors.push([nx, ny, dx, dy]);
          }
        }
        if (neighbors.length) {
          // choose a random neighbor and knock down the wall between current cell and neighbor
          const [nx, ny, dx, dy] = neighbors[Math.floor(Math.random() * neighbors.length)];
          maze[ny - dy / 2][nx - dx / 2] = 0;
          maze[ny][nx] = 0;
          stack.push([nx, ny]);
        } else {
          stack.pop();
        }
      }
      // clear the start and end cells to guarantee an entrance and exit
      maze[1][1] = 0;
      maze[height - 2][width - 2] = 0;
      return maze;
    }

    // Maze dimensions and cell sizing.  A larger maze makes for a more challenging
    // exploration.  Adjust cellSize to control the corridor width in the 3D scene.
    const mazeWidth = 15;
    const mazeHeight = 15;
    const cellSize = 4;
    const wallHeight = 3;
    const maze = generateMaze(mazeWidth, mazeHeight);

    // Create a Three.js scene, camera, and renderer.  A dark background enhances
    // contrast for the green walls and bright exit.  Lighting is kept simple with
    // an ambient component for general illumination and a directional light for shading.
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    // Floor: a simple plane to walk on
    const floorGeometry = new THREE.PlaneGeometry(mazeWidth * cellSize, mazeHeight * cellSize);
    const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    // Walls: build boxes for every cell marked as 1 in the maze.  Position is offset so
    // that the maze is centered around the origin.  The green colour echoes the
    // labyrinth image provided by the user.
    const wallGeometry = new THREE.BoxGeometry(cellSize, wallHeight, cellSize);
    const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x3a5d0f });
    for (let z = 0; z < mazeHeight; z++) {
      for (let x = 0; x < mazeWidth; x++) {
        if (maze[z][x] === 1) {
          const wall = new THREE.Mesh(wallGeometry, wallMaterial);
          wall.position.set(
            (x - mazeWidth / 2) * cellSize + cellSize / 2,
            wallHeight / 2,
            (z - mazeHeight / 2) * cellSize + cellSize / 2
          );
          scene.add(wall);
        }
      }
    }

    // Exit tile: a brightly coloured square on the ground indicates where to finish the maze
    const exitGeometry = new THREE.BoxGeometry(cellSize, 0.1, cellSize);
    const exitMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const exit = new THREE.Mesh(exitGeometry, exitMaterial);
    exit.position.set(
      (mazeWidth - 2 - mazeWidth / 2) * cellSize + cellSize / 2,
      0.05,
      (mazeHeight - 2 - mazeHeight / 2) * cellSize + cellSize / 2
    );
    scene.add(exit);

    // PointerLockControls give the player a first‑person view and capture mouse movement.
    const controls = new PointerLockControls(camera, renderer.domElement);
    // Position the camera at the start cell (1,1) with a slight height so the player
    // appears to be standing.  Coordinates are offset to center the maze on the origin.
    camera.position.set(
      (1 - mazeWidth / 2) * cellSize + cellSize / 2,
      1.0,
      (1 - mazeHeight / 2) * cellSize + cellSize / 2
    );
    scene.add(controls.getObject());

    // Handle overlay and pointer lock.  When the player clicks the start button we
    // request pointer lock; the overlay is hidden while locked and shown again when
    // unlocked.
    const overlay = document.getElementById('overlay');
    const startButton = document.getElementById('startButton');
    startButton.addEventListener('click', () => {
      controls.lock();
    });
    controls.addEventListener('lock', () => {
      overlay.style.display = 'none';
    });
    controls.addEventListener('unlock', () => {
      overlay.style.display = '';
    });

    // Movement flags and parameters.  Key events toggle these flags; the velocity is
    // dampened each frame to provide smoother acceleration and deceleration.  Speed
    // controls how fast the player can travel through the maze.
    const move = { forward: false, backward: false, left: false, right: false };
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    const speed = 5.0;

    document.addEventListener('keydown', (event) => {
      switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
          move.forward = true;
          break;
        case 'ArrowLeft':
        case 'KeyA':
          move.left = true;
          break;
        case 'ArrowDown':
        case 'KeyS':
          move.backward = true;
          break;
        case 'ArrowRight':
        case 'KeyD':
          move.right = true;
          break;
      }
    });
    document.addEventListener('keyup', (event) => {
      switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
          move.forward = false;
          break;
        case 'ArrowLeft':
        case 'KeyA':
          move.left = false;
          break;
        case 'ArrowDown':
        case 'KeyS':
          move.backward = false;
          break;
        case 'ArrowRight':
        case 'KeyD':
          move.right = false;
          break;
      }
    });

    // Status element for win notification
    const status = document.getElementById('status');
    let prevTime = performance.now();

    function animate() {
      requestAnimationFrame(animate);
      const time = performance.now();
      const delta = (time - prevTime) / 1000;
      // Apply friction to velocity
      velocity.x -= velocity.x * 10.0 * delta;
      velocity.z -= velocity.z * 10.0 * delta;
      // Determine direction from movement flags
      direction.z = Number(move.forward) - Number(move.backward);
      direction.x = Number(move.right) - Number(move.left);
      direction.normalize();
      if (move.forward || move.backward) velocity.z -= direction.z * speed * delta;
      if (move.left || move.right) velocity.x -= direction.x * speed * delta;
      const controlObj = controls.getObject();
      const prevPosition = controlObj.position.clone();
      controlObj.translateX(velocity.x * delta);
      controlObj.translateZ(velocity.z * delta);
      // Collision detection: check the maze cell corresponding to the new position.
      // Convert player coordinates to cell indices by translating and scaling.
      const px = (controlObj.position.x + (mazeWidth * cellSize) / 2) / cellSize;
      const pz = (controlObj.position.z + (mazeHeight * cellSize) / 2) / cellSize;
      const cellX = Math.floor(px);
      const cellZ = Math.floor(pz);
      if (
        cellX < 0 ||
        cellX >= mazeWidth ||
        cellZ < 0 ||
        cellZ >= mazeHeight ||
        maze[cellZ][cellX] === 1
      ) {
        // Hit a wall: revert position and zero out velocity to prevent sliding
        controlObj.position.copy(prevPosition);
        velocity.x = 0;
        velocity.z = 0;
      }
      // Victory condition: player is within half a cell of the exit
      if (
        Math.abs(controlObj.position.x - exit.position.x) < cellSize * 0.5 &&
        Math.abs(controlObj.position.z - exit.position.z) < cellSize * 0.5
      ) {
        status.textContent = 'Bravo ! Vous avez terminé le labyrinthe.';
      }
      renderer.render(scene, camera);
      prevTime = time;
    }
    animate();
  </script>
</body>
</html>
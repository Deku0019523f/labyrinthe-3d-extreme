<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>Jeu Labyrinthe 3D Extrême</title>
  <style>
    /* Basic resets and layout */
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #111;
      color: #fff;
      font-family: Arial, sans-serif;
    }
    /* Overlay used before pointer lock is engaged */
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1;
      text-align: center;
    }
    #overlay img {
      max-width: 80%;
      height: auto;
      margin-bottom: 1rem;
      border-radius: 8px;
    }
    #overlay button {
      padding: 0.5rem 1.5rem;
      font-size: 1.25rem;
      cursor: pointer;
      border: none;
      border-radius: 4px;
      background: #5a9e30;
      color: white;
    }
    #overlay button:hover {
      background: #4a8b29;
    }
    /* Status message in the top left corner */
    #status {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.5);
      padding: 0.5rem 1rem;
      border-radius: 4px;
      font-size: 1rem;
      z-index: 2;
    }
  </style>
</head>
<body>
  <!-- Overlay with title, image and start button -->
  <div id="overlay">
    <h1>Bienvenue dans le labyrinthe 3D !</h1>
    <p>Utilisez les touches WASD ou les flèches pour vous déplacer.<br />Cliquez sur le bouton pour commencer.</p>
    <button id="startButton">Commencer</button>
  </div>
  <!-- Status display (e.g. victory message) -->
  <div id="status"></div>
  <!-- Main script: generates the maze and handles the 3D scene -->
  <script type="module">
    // Import Three.js from CDN. Modules are used to simplify bundling and allow
    // direct ES module imports. We avoid PointerLockControls to improve
    // compatibility on GitHub Pages, using keyboard‑only rotation instead.
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js';

    /**
     * Generate a maze using randomized depth‑first search. The maze array
     * contains 0 for open passages and 1 for walls. Start and end cells are
     * cleared explicitly. Cells are processed in steps of two to maintain
     * single‑cell wide corridors.
     */
    function generateMaze(width, height) {
      const maze = Array.from({ length: height }, () => Array(width).fill(1));
      const stack = [];
      const directions = [ [0, -2], [2, 0], [0, 2], [-2, 0] ];
      let cx = 1;
      let cy = 1;
      maze[cy][cx] = 0;
      stack.push([cx, cy]);
      while (stack.length) {
        const [x, y] = stack[stack.length - 1];
        const neighbors = [];
        for (const [dx, dy] of directions) {
          const nx = x + dx;
          const ny = y + dy;
          if (nx > 0 && ny > 0 && nx < width - 1 && ny < height - 1 && maze[ny][nx] === 1) {
            neighbors.push([nx, ny, dx, dy]);
          }
        }
        if (neighbors.length) {
          const [nx, ny, dx, dy] = neighbors[Math.floor(Math.random() * neighbors.length)];
          maze[ny - dy / 2][nx - dx / 2] = 0;
          maze[ny][nx] = 0;
          stack.push([nx, ny]);
        } else {
          stack.pop();
        }
      }
      maze[1][1] = 0;
      maze[height - 2][width - 2] = 0;
      return maze;
    }

    // Maze parameters
    const mazeWidth = 15;
    const mazeHeight = 15;
    const cellSize = 4;
    const wallHeight = 3;
    const maze = generateMaze(mazeWidth, mazeHeight);

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lighting
    scene.add(new THREE.AmbientLight(0xffffff, 0.3));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);

    // Floor
    const floorGeometry = new THREE.PlaneGeometry(mazeWidth * cellSize, mazeHeight * cellSize);
    const floorMaterial = new THREE.MeshLambertMaterial({ color: 0x444444 });
    const floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    // Walls
    const wallGeometry = new THREE.BoxGeometry(cellSize, wallHeight, cellSize);
    const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x3a5d0f });
    for (let z = 0; z < mazeHeight; z++) {
      for (let x = 0; x < mazeWidth; x++) {
        if (maze[z][x] === 1) {
          const wall = new THREE.Mesh(wallGeometry, wallMaterial);
          wall.position.set(
            (x - mazeWidth / 2) * cellSize + cellSize / 2,
            wallHeight / 2,
            (z - mazeHeight / 2) * cellSize + cellSize / 2
          );
          scene.add(wall);
        }
      }
    }

    // Exit indicator
    const exitGeometry = new THREE.BoxGeometry(cellSize, 0.1, cellSize);
    const exitMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    const exit = new THREE.Mesh(exitGeometry, exitMaterial);
    exit.position.set(
      (mazeWidth - 2 - mazeWidth / 2) * cellSize + cellSize / 2,
      0.05,
      (mazeHeight - 2 - mazeHeight / 2) * cellSize + cellSize / 2
    );
    scene.add(exit);

    // Position camera at start
    camera.position.set(
      (1 - mazeWidth / 2) * cellSize + cellSize / 2,
      1.0,
      (1 - mazeHeight / 2) * cellSize + cellSize / 2
    );
    // Orientation angles
    let yaw = 0;

    // Hide overlay on start button click
    const overlay = document.getElementById('overlay');
    document.getElementById('startButton').addEventListener('click', () => {
      overlay.style.display = 'none';
    });

    // Movement flags and parameters. We include rotation flags for left/right.
    const move = {
      forward: false,
      backward: false,
      rotLeft: false,
      rotRight: false
    };
    const velocity = new THREE.Vector3();
    const speed = 5.0;
    const rotateSpeed = 2.5; // radians per second

    document.addEventListener('keydown', (event) => {
      switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
          move.forward = true;
          break;
        case 'ArrowDown':
        case 'KeyS':
          move.backward = true;
          break;
        case 'ArrowLeft':
        case 'KeyA':
          move.rotLeft = true;
          break;
        case 'ArrowRight':
        case 'KeyD':
          move.rotRight = true;
          break;
      }
    });
    document.addEventListener('keyup', (event) => {
      switch (event.code) {
        case 'ArrowUp':
        case 'KeyW':
          move.forward = false;
          break;
        case 'ArrowDown':
        case 'KeyS':
          move.backward = false;
          break;
        case 'ArrowLeft':
        case 'KeyA':
          move.rotLeft = false;
          break;
        case 'ArrowRight':
        case 'KeyD':
          move.rotRight = false;
          break;
      }
    });

    const status = document.getElementById('status');
    let prevTime = performance.now();

    function animate() {
      requestAnimationFrame(animate);
      const time = performance.now();
      const delta = (time - prevTime) / 1000;
      // Rotation
      if (move.rotLeft) yaw += rotateSpeed * delta;
      if (move.rotRight) yaw -= rotateSpeed * delta;
      camera.rotation.y = yaw;
      // Reset velocity and apply movement based on forward/backward flags
      velocity.set(0, 0, 0);
      if (move.forward) {
        velocity.x -= Math.sin(yaw) * speed;
        velocity.z -= Math.cos(yaw) * speed;
      }
      if (move.backward) {
        velocity.x += Math.sin(yaw) * speed;
        velocity.z += Math.cos(yaw) * speed;
      }
      // Apply delta time
      const nextX = camera.position.x + velocity.x * delta;
      const nextZ = camera.position.z + velocity.z * delta;
      // Collision detection on the new position
      const px = (nextX + (mazeWidth * cellSize) / 2) / cellSize;
      const pz = (nextZ + (mazeHeight * cellSize) / 2) / cellSize;
      const cellX = Math.floor(px);
      const cellZ = Math.floor(pz);
      if (
        cellX >= 0 && cellX < mazeWidth && cellZ >= 0 && cellZ < mazeHeight &&
        maze[cellZ][cellX] === 0
      ) {
        camera.position.x = nextX;
        camera.position.z = nextZ;
      }
      // Victory check
      if (
        Math.abs(camera.position.x - exit.position.x) < cellSize * 0.5 &&
        Math.abs(camera.position.z - exit.position.z) < cellSize * 0.5
      ) {
        status.textContent = 'Bravo ! Vous avez terminé le labyrinthe.';
      }
      renderer.render(scene, camera);
      prevTime = time;
    }
    animate();
  </script>
</body>
</html>